#!/usr/bin/env node
/* eslint no-console:off */
const { createCanvas, loadImage } = require('canvas')
const {join, basename} = require('path');
const {writeFileSync, readFileSync} = require('fs');
const emojiDataArray = require('react-emojione/lib/data/emoji-data');
const getEmojiosByCategory = require('./utils/get-emojios-by-category');
const exec = require('await-exec')
const config = require("./config");

const EMOJIS_PER_ROW = 6;
const EMOJIONE_VERSION = '3.1.2';
const emojiosByCategory = getEmojiosByCategory(config.notAllowed);

const sets = config.sizes.map(size=>(
  {
    size,
    padding: Math.round(size/2),
    src: join(__dirname, `./node_modules/react-emojione/assets/emojione-${EMOJIONE_VERSION}-128x128`),
    out: (suffix)=>join(__dirname, `${config.output}/emojione-${suffix}-${size}x${size}.png`),
    outMap: join(__dirname, `${config.output}/emojione-map-${size}x${size}.js`),
  }
));

const readEmoji = async (src, code) => {
    const filename = code.split('-').filter(c => !['200d', 'fe0f'].includes(c)).join('-');
    let img = await loadImage(join(src, `${filename}.png`));
    return img;
};

const createSprite = async ({emojiDataMap, shortnames, category, size, src, out, padding}) => {
    const width = EMOJIS_PER_ROW * (size + padding) + padding;
    const height = Math.ceil(emojiDataMap.size / EMOJIS_PER_ROW) * (size + padding) + padding;
    const count = shortnames.length;
    const canvas = new createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    const positionsMap = {};
   
    // create sprites
    for (let e = 0, x = padding, y = padding, row=0; e < count; x = padding, y += size + padding, row++) {
        for (let i = 0, col = 0; i < EMOJIS_PER_ROW && e < count; i++, e++, x += size + padding, col++) {
            const name = shortnames[e];
            const code = emojiDataMap.get(name);
            
            const img = await readEmoji(src, code);
            if (img) {
              positionsMap[name] = {x, y, row, col, size, padding};
              ctx.drawImage(img, x, y, size, size);
            }
        }
    }
    const dest = out(category);
    writeFileSync(dest, canvas.toBuffer());
    console.log('Wrote sprite', {width, height, count, dest});
    await optimizeImg(dest);
    return positionsMap;
};

const createSpritePositions = ({outMap, positions}) => {
    console.log('Writing sprite positions', outMap);
    const header = `/*eslint-disable*/
// Do not edit!
// This file was auto-generated by ${basename(__filename)}
export default `;

    writeFileSync(outMap, `${header} ${JSON.stringify(positions, null, 1)};`);
};


//Start

const start = async ()=>{

  const positionsMap = {};

  //Initialize Map to Guaranty order
  Object.keys(emojiosByCategory).map((key)=>{
    sets.map((props)=>{
      positionsMap[props.size]={...positionsMap[props.size], [key]: {}};  
    })  
  });

  //run all promisses
  await Promise.all(
    Object.keys(emojiosByCategory).map(async (key)=>{
      const data = emojiosByCategory[key];

      const shortnames = [];
      const emojiDataMap = new Map(
          
        data.map((dataValue)=>{
          const [code, name] = emojiDataArray.find( ([code, names])=>{ 
            const found = names.find( (name)=>name==dataValue.name);  
            return found ? [names, code] : undefined;
          });
          shortnames.push(dataValue.name);
          return [dataValue.name, code];
        })
      )
      
      return await Promise.all(
        sets.map(async (props)=>{
            const positions = await createSprite({...props, emojiDataMap, shortnames, category: key});
            positionsMap[props.size] = {...positionsMap[props.size], [key]: positions};
        })
      );

    })
  );

  sets.forEach(async (props)=>{
    createSpritePositions({...props, positions: positionsMap[props.size]});
  });

};


const optimizeImg = async (filename) => {
  //Requires: https://github.com/dkunin/optimizilla-cli installed global
  return await exec(`optimizilla ${filename} -r`);
};



start();

